import pandas as pd
import numpy as np
import os
import glob
import matplotlib.pyplot as plt
import seaborn as sns
from pathlib import Path
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report, confusion_matrix, accuracy_score

# ==========================================
# 1. 設定・パスの定義
# ==========================================

# ★ここをあなたの環境に合わせて変更してください
# 手動分類したフォルダの親ディレクトリ (Dドライブ直下なら "D:\\")
MALWARE_ROOT_DIR = r"D:\CSV_Flow\CSV_Attacked" 

# 正常データの入っているフォルダ (※ここだけは別で読み込みます)
NORMAL_DIR = r"D:\CSV_Flow\CSV_Normal\*.csv"

# サンプリング率 (メモリ不足防止 & 不均衡対策)
RATIO_NORMAL = 1.0     # 正常は全件使用
RATIO_MALWARE = 0.005  # 攻撃は0.5% (データ量に応じて調整してください)

# 削除する列
DROP_COLUMNS = ['flow_id', 'src_ip', 'dst_ip', 'src_port', 'dst_port', 'timestamp', 'label']

# ==========================================
# 2. 関数定義
# ==========================================

def load_csv_with_label(filepath, label_name, ratio):
    """ CSVを読み込み、指定されたラベルを付与して返す """
    try:
        df = pd.read_csv(filepath)
        
        # 軽量化: 列削除
        cols = [c for c in DROP_COLUMNS if c in df.columns]
        df.drop(columns=cols, inplace=True)
        
        # 軽量化: サンプリング
        if ratio < 1.0:
            df = df.sample(frac=ratio, random_state=42)
            
        # 軽量化: 型変換
        float_cols = df.select_dtypes(include=['float64']).columns
        df[float_cols] = df[float_cols].astype('float32')
        
        # ★ラベル付与（フォルダ名などから受け取った文字列）
        df['label'] = label_name
        
        return df
    except Exception as e:
        print(f"  Error reading {os.path.basename(filepath)}: {e}")
        return pd.DataFrame()

def load_malware_from_folders(root_path, ratio):
    """ フォルダ構造を走査してデータを読み込む """
    df_list = []
    root = Path(root_path)
    
    # ルート以下のすべてのサブフォルダ（Mirai, Kenjiro...）を取得
    subfolders = [f for f in root.iterdir() if f.is_dir()]
    
    print(f"検索対象フォルダ: {[f.name for f in subfolders]}")
    
    for folder in subfolders:
        label_name = folder.name  # フォルダ名をラベルにする (例: "Mirai")
        csv_files = list(folder.glob("*.csv"))
        
        if not csv_files:
            continue
            
        print(f"--- Loading {label_name} ({len(csv_files)} files) ---")
        
        for file in csv_files:
            df = load_csv_with_label(file, label_name, ratio)
            if not df.empty:
                df_list.append(df)
                
    if not df_list:
        return pd.DataFrame()
    return pd.concat(df_list, ignore_index=True)

def preprocess_data(df):
    if df.empty: return None, None
    # シャッフル
    df = df.sample(frac=1, random_state=42).reset_index(drop=True)
    y = df['label']
    X = df.drop(columns=['label'])
    # 欠損値処理
    X = X.replace([np.inf, -np.inf], np.nan).fillna(0)
    return X, y

# ==========================================
# 3. メイン処理
# ==========================================

def main():
    print("=== 手動分類フォルダを用いた多値分類 ===")
    
    # 1. 正常データの読み込み
    print("\n[Step 1-A] 正常データの読み込み")
    normal_files = glob.glob(NORMAL_DIR)
    df_list_normal = []
    for f in normal_files:
        df = load_csv_with_label(f, "Normal", RATIO_NORMAL)
        df_list_normal.append(df)
    
    if df_list_normal:
        df_normal = pd.concat(df_list_normal, ignore_index=True)
    else:
        print("警告: 正常データが見つかりません。")
        df_normal = pd.DataFrame()

    # 2. 攻撃データの読み込み (フォルダ構造から)
    print("\n[Step 1-B] 攻撃データの読み込み (フォルダ別)")
    df_malware = load_malware_from_folders(MALWARE_ROOT_DIR, RATIO_MALWARE)
    
    # 結合
    df_full = pd.concat([df_normal, df_malware], ignore_index=True)
    
    # データ内訳表示
    print("\n[データ内訳]")
    print(df_full['label'].value_counts())
    
    if len(df_full) == 0:
        return

    # 3. 前処理 & 分割
    print("\n[Step 2] 前処理 & 分割")
    X, y = preprocess_data(df_full)
    
    # 層化抽出 (Stratified Split) で分割
    X_train, X_test, y_train, y_test = train_test_split(
        X, y, test_size=0.3, random_state=42, stratify=y
    )

    # 4. 学習
    print(f"\n[Step 3] 学習 (Train: {len(X_train)})")
    rf_model = RandomForestClassifier(
        n_estimators=100, 
        class_weight='balanced', 
        random_state=42, 
        n_jobs=-1
    )
    rf_model.fit(X_train, y_train)
    
    # 5. 評価
    print("\n[Step 4] 評価結果")
    y_pred = rf_model.predict(X_test)
    print(f"Accuracy: {accuracy_score(y_test, y_pred):.4f}")
    
    # 分類レポート
    print("\n--- Classification Report ---")
    print(classification_report(y_test, y_pred, zero_division=0))
    
    # ヒートマップ表示
    labels = sorted(y_test.unique())
    cm = confusion_matrix(y_test, y_pred, labels=labels)
    
    plt.figure(figsize=(12, 10)) # クラスが多いので少し大きめに
    sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', xticklabels=labels, yticklabels=labels)
    plt.ylabel('Actual')
    plt.xlabel('Predicted')
    plt.title('Confusion Matrix (Folder-based Labels)')
    plt.xticks(rotation=45)
    plt.tight_layout()
    plt.show()

if __name__ == "__main__":
    main()